# GitHub Actions: Job in Container & Docker Container Action Demo

This repository demonstrates how to configure a GitHub Actions workflow to:

1.  **Run an entire job's steps within a specified Docker container.** This allows you to define a consistent and isolated environment for your job, complete with specific tools and versions.
2.  **Execute a Docker container action as a step within that job.** This showcases how GitHub Actions can orchestrate different containerized tasks, even when the main job itself is already running in a container.

## Workflow File: `.github/workflows/container-job-and-action-demo.yml`

The core of this demonstration is the workflow file located at [`.github/workflows/container-job-and-action-demo.yml`](./.github/workflows/container-job-and-action-demo.yml).

### Key Features Demonstrated:

*   **Job-level Container (`container:` keyword):**
    *   The `job_in_container` job is configured to run on an `ubuntu-latest` runner, but its steps are executed inside a Docker container specified by `container.image` (e.g., `node:18-alpine`).
    *   This means commands like `node --version` or `apk add` (if using an Alpine-based image) will operate within the context of that container's environment.

*   **Docker Container Action (`uses: ...docker-action@vX`):**
    *   Within the `job_in_container`, there's a step that uses `actions/hello-world-docker-action@v2`.
    *   This is a self-contained action that itself runs in a Docker container.
    *   GitHub Actions manages the execution of this action's container, even though the parent job is also containerized. This typically involves Docker-in-Docker or similar socket sharing capabilities provided by the GitHub-hosted runner.

### Workflow Breakdown:

The `job_in_container` job performs the following steps:

1.  **Checkout code**: Uses `actions/checkout@v4` to make the repository's code available.
2.  **Show Node.js version (from job container)**: Executes shell commands (`node --version`, `npm --version`, `whoami`) inside the job's primary container (e.g., `node:18-alpine`). This confirms that the job steps are indeed running within the specified container environment.
3.  **Run a Docker Container Action**:
    *   Calls the `actions/hello-world-docker-action@v2`.
    *   This action runs in its *own* separate Docker container.
    *   An input `who-to-greet` is passed to this action.
4.  **Output from Docker Container Action**: Retrieves and prints outputs (like `time`) generated by the `hello-world-docker-action`.
5.  **Another command in the job container**: Further demonstrates commands running inside the primary job container, such as installing a package using the container's package manager (`apk` for Alpine).

## How to Use This Demo

1.  **Examine the Workflow File**:
    Open [`.github/workflows/container-job-and-action-demo.yml`](./.github/workflows/container-job-and-action-demo.yml) to understand its structure.

2.  **Trigger the Workflow**:
    *   The workflow is configured to run on `push` to the `main` branch.
    *   It can also be manually triggered via the `workflow_dispatch` event:
        1.  Go to the "Actions" tab of this repository on GitHub.
        2.  Select the "Container Job and Docker Action Demo" workflow from the list on the left.
        3.  Click the "Run workflow" dropdown, select the branch (e.g., `main`), and click the "Run workflow" button.

3.  **Observe the Workflow Run**:
    *   Navigate to the "Actions" tab and click on the latest run of the "Container Job and Docker Action Demo" workflow.
    *   Expand the `Job Running in a Container` job.
    *   Inspect the logs for each step:
        *   Notice the output of commands like `node --version` or `whoami` in step "2. Show Node.js version..." to see the job container's environment.
        *   Observe the logs for step "3. Run a Docker Container Action" to see the `hello-world-docker-action` execute.
        *   Check the output in step "4. Output from Docker Container Action".

## Key Concepts Illustrated

*   **Environment Isolation**: Using a job-level container ensures that your job runs in a predictable environment, regardless of the underlying runner's configuration (beyond needing Docker support).
*   **Tooling Consistency**: You can pre-install all necessary tools and dependencies in your chosen Docker image, simplifying your workflow steps.
*   **Composability of Actions**: GitHub Actions allows you to use Docker container actions even if your job itself is containerized, providing flexibility in how you build your CI/CD pipelines.

This demonstration provides a practical example of leveraging Docker containers at different levels within GitHub Actions to create robust and customized automation.
---
*Generated by AI (Copilot) on 2025-05-21 for user @whsalazar.*
